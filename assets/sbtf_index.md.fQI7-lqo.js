import{a as ce,k as fe,c as de,b as _e,n as ye}from"./chunks/index._vIfVuXs.js";import{d as me,h as v,k as Q,l as ve,o as N,b as we,w as u,J as o,p as n,m as y,a as p,t as H,c as T,e as xe}from"./chunks/framework.TV9jg5Us.js";import"./chunks/theme.rXmDXHr-.js";function Me(i,e){return ce(e,function(t){return i[t]})}function He(i){return i==null?[]:Me(i,fe(i))}var Ae=Math.floor,Ee=Math.random;function ze(i,e){return i+Ae(Ee()*(e-i+1))}function j(i,e){var t=-1,r=i.length,s=r-1;for(e=e===void 0?r:e;++t<e;){var l=ze(t,s),k=i[l];i[l]=i[t],i[t]=k}return i.length=e,i}function Pe(i){return j(de(i))}function ke(i){return j(He(i))}function be(i){var e=_e(i)?Pe:ke;return e(i)}var V={},m={},P={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 *
 * @class
 */let $e=class A{constructor(e,t,r){if(typeof e!="function")throw new Error("Heap constructor expects a compare function");this._compare=e,this._nodes=Array.isArray(t)?t:[],this._leaf=r||null}toArray(){return Array.from(this._nodes)}_hasLeftChild(e){return e*2+1<this.size()}_hasRightChild(e){return e*2+2<this.size()}_compareAt(e,t){return this._compare(this._nodes[e],this._nodes[t])}_swap(e,t){const r=this._nodes[e];this._nodes[e]=this._nodes[t],this._nodes[t]=r}_shouldSwap(e,t){return e<0||e>=this.size()||t<0||t>=this.size()?!1:this._compareAt(e,t)>0}_compareChildrenOf(e){if(!this._hasLeftChild(e)&&!this._hasRightChild(e))return-1;const t=e*2+1,r=e*2+2;return this._hasLeftChild(e)?this._hasRightChild(e)&&this._compareAt(t,r)>0?r:t:r}_compareChildrenBefore(e,t,r){return this._compareAt(r,t)<=0&&r<e?r:t}_heapifyUp(e){let t=e,r=Math.floor((t-1)/2);for(;this._shouldSwap(r,t);)this._swap(r,t),t=r,r=Math.floor((t-1)/2)}_heapifyDown(e){let t=e,r=this._compareChildrenOf(t);for(;this._shouldSwap(t,r);)this._swap(t,r),t=r,r=this._compareChildrenOf(t)}_heapifyDownUntil(e){let t=0,r=1,s=2,l;for(;r<e;)l=this._compareChildrenBefore(e,r,s),this._shouldSwap(t,l)&&this._swap(t,l),t=l,r=t*2+1,s=t*2+2}insert(e){return this._nodes.push(e),this._heapifyUp(this.size()-1),(this._leaf===null||this._compare(e,this._leaf)>0)&&(this._leaf=e),this}push(e){return this.insert(e)}extractRoot(){if(this.isEmpty())return null;const e=this.root();return this._nodes[0]=this._nodes[this.size()-1],this._nodes.pop(),this._heapifyDown(0),e===this._leaf&&(this._leaf=this.root()),e}pop(){return this.extractRoot()}sort(){for(let e=this.size()-1;e>0;e-=1)this._swap(0,e),this._heapifyDownUntil(e);return this._nodes}fix(){for(let e=Math.floor(this.size()/2)-1;e>=0;e-=1)this._heapifyDown(e);for(let e=Math.floor(this.size()/2);e<this.size();e+=1){const t=this._nodes[e];(this._leaf===null||this._compare(t,this._leaf)>0)&&(this._leaf=t)}return this}isValid(){const e=t=>{let r=!0,s=!0;if(this._hasLeftChild(t)){const l=t*2+1;if(this._compareAt(t,l)>0)return!1;r=e(l)}if(this._hasRightChild(t)){const l=t*2+2;if(this._compareAt(t,l)>0)return!1;s=e(l)}return r&&s};return e(0)}clone(){return new A(this._compare,this._nodes.slice(),this._leaf)}root(){return this.isEmpty()?null:this._nodes[0]}top(){return this.root()}leaf(){return this._leaf}size(){return this._nodes.length}isEmpty(){return this.size()===0}clear(){this._nodes=[],this._leaf=null}[Symbol.iterator](){let e=this.size();return{next:()=>(e-=1,{value:this.pop(),done:e===-1})}}static heapify(e,t){if(!Array.isArray(e))throw new Error("Heap.heapify expects an array of values");if(typeof t!="function")throw new Error("Heap.heapify expects a compare function");return new A(t,e).fix()}static isHeapified(e,t){return new A(t,e).isValid()}};P.Heap=$e;var F={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */const{Heap:q}=P,S=i=>(e,t)=>{const r=typeof i=="function"?i(e):e,s=typeof i=="function"?i(t):t;return r<=s?-1:1};let Qe=class E{constructor(e,t){this._getCompareValue=e,this._heap=t||new q(S(e))}toArray(){return Array.from(this._heap._nodes)}insert(e){return this._heap.insert(e)}push(e){return this.insert(e)}extractRoot(){return this._heap.extractRoot()}pop(){return this.extractRoot()}sort(){return this._heap.sort()}fix(){return this._heap.fix()}isValid(){return this._heap.isValid()}root(){return this._heap.root()}top(){return this.root()}leaf(){return this._heap.leaf()}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}clone(){return new E(this._getCompareValue,this._heap.clone())}[Symbol.iterator](){let e=this.size();return{next:()=>(e-=1,{value:this.pop(),done:e===-1})}}static heapify(e,t){if(!Array.isArray(e))throw new Error("MinHeap.heapify expects an array");const r=new q(S(t),e);return new E(t,r).fix()}static isHeapified(e,t){const r=new q(S(t),e);return new E(t,r).isValid()}};F.MinHeap=Qe;var G={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */const{Heap:R}=P,g=i=>(e,t)=>{const r=typeof i=="function"?i(e):e,s=typeof i=="function"?i(t):t;return r<s?1:-1};let qe=class z{constructor(e,t){this._getCompareValue=e,this._heap=t||new R(g(e))}insert(e){return this._heap.insert(e)}push(e){return this.insert(e)}extractRoot(){return this._heap.extractRoot()}pop(){return this.extractRoot()}sort(){return this._heap.sort()}toArray(){return Array.from(this._heap._nodes)}fix(){return this._heap.fix()}isValid(){return this._heap.isValid()}root(){return this._heap.root()}top(){return this.root()}leaf(){return this._heap.leaf()}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}clone(){return new z(this._getCompareValue,this._heap.clone())}[Symbol.iterator](){let e=this.size();return{next:()=>(e-=1,{value:this.pop(),done:e===-1})}}static heapify(e,t){if(!Array.isArray(e))throw new Error("MaxHeap.heapify expects an array");const r=new R(g(t),e);return new z(t,r).fix()}static isHeapified(e,t){const r=new R(g(t),e);return new z(t,r).isValid()}};G.MaxHeap=qe;const{Heap:Se}=P,{MinHeap:Re}=F,{MaxHeap:ge}=G;m.Heap=Se;m.MinHeap=Re;m.MaxHeap=ge;/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:Ne,MinHeap:U}=m,Ce=i=>(e,t)=>{const r=typeof i=="function"?i(e):e,s=typeof i=="function"?i(t):t;return r<=s?-1:1};let De=class K{constructor(e,t){if(e&&typeof e!="function")throw new Error("MinPriorityQueue constructor requires a callback for object values");this._heap=t||new U(e)}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(e){return this._heap.insert(e)}push(e){return this.enqueue(e)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(e){if(typeof e!="function")throw new Error("MinPriorityQueue remove expects a callback");const t=[],r=[];for(;!this.isEmpty();){const s=this.pop();e(s)?t.push(s):r.push(s)}return r.forEach(s=>this.push(s)),t}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let e=this.size();return{next:()=>(e-=1,{value:this.pop(),done:e===-1})}}static fromArray(e,t){const r=new Ne(Ce(t),e);return new K(t,new U(t,r).fix())}};V.MinPriorityQueue=De;var W={};/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:Le,MaxHeap:I}=m,Oe=i=>(e,t)=>{const r=typeof i=="function"?i(e):e,s=typeof i=="function"?i(t):t;return r<s?1:-1};let Be=class X{constructor(e,t){if(e&&typeof e!="function")throw new Error("MaxPriorityQueue constructor requires a callback for object values");this._heap=t||new I(e)}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(e){return this._heap.insert(e)}push(e){return this.enqueue(e)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(e){if(typeof e!="function")throw new Error("MaxPriorityQueue remove expects a callback");const t=[],r=[];for(;!this.isEmpty();){const s=this.pop();e(s)?t.push(s):r.push(s)}return r.forEach(s=>this.push(s)),t}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let e=this.size();return{next:()=>(e-=1,{value:this.pop(),done:e===-1})}}static fromArray(e,t){const r=new Le(Oe(t),e);return new X(t,new I(t,r).fix())}};W.MaxPriorityQueue=Be;var Y={};/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:Ue}=m;let Ie=class Z{constructor(e,t){if(typeof e!="function")throw new Error("PriorityQueue constructor expects a compare function");this._heap=new Ue(e,t),t&&this._heap.fix()}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(e){return this._heap.insert(e)}push(e){return this.enqueue(e)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(e){if(typeof e!="function")throw new Error("PriorityQueue remove expects a callback");const t=[],r=[];for(;!this.isEmpty();){const s=this.pop();e(s)?t.push(s):r.push(s)}return r.forEach(s=>this.push(s)),t}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let e=this.size();return{next:()=>(e-=1,{value:this.pop(),done:e===-1})}}static fromArray(e,t){return new Z(t,e)}};Y.PriorityQueue=Ie;const{MinPriorityQueue:Je}=V,{MaxPriorityQueue:Te}=W,{PriorityQueue:je}=Y;var J={MinPriorityQueue:Je,MaxPriorityQueue:Te,PriorityQueue:je};function Ve(i,e){var t,r,s;return e>=3?i.repetition===0?(t=1,r=1):i.repetition===1?(t=6,r=2):(t=Math.round(i.interval*i.efactor),r=i.repetition+1):(t=1,r=0),s=i.efactor+(.1-(5-e)*(.08+(5-e)*.02)),s<1.3&&(s=1.3),{interval:t,repetition:r,efactor:s}}const Fe={class:"button-container"},Ge=y("strong",null,"这个存储是存储在本地的，所以换了浏览器之后就需要重来了。",-1),Ke={class:"radical"},We={key:0},Xe=me({__name:"Practice",setup(i){const{NButton:e,NConfigProvider:t,NProgress:r,NSpace:s,NCard:l,NModal:k,NInput:ee,NP:b,NH1:te,NUl:re,NLi:C,NA:ie,darkTheme:se}=ye,ne={q:"气欠犬犭青其日曰攴",w:"韦文瓦王攵夂夊亠韋",r:"人亻",t:"田土士",y:"又用业页頁衣羊言讠音酉尢疋",p:"片皮⺮丿彡",s:"十山尸手水石矢舌身鼠示食饣飠殳豕丨厶",d:"刀大歹斗鬥豆丶冫氵癶",f:"方风風父缶扌",g:"工弓广戈瓜革鬼骨艮宀冖",h:"一户火禾黑虍",j:"几己巾斤见見臼角金钅釒纟糹",k:"口囗匚凵冂",l:"力立龙龍里鹿耒刂忄廴辶灬卤鹵",z:"乙子舟自走豸隹足⻊爪爫丬爿罒長巛",x:"夕小心穴血覀辛彐糸⺍⺌",c:"厂寸车車虫赤辰齿齒彳艹卝屮",v:"二儿耳月羽鱼魚雨聿阝卩",b:"八比贝貝白鼻卜髟勹疒丷",n:"女牛告鸟鳥衤礻廾止",m:"马馬门門毛木皿目麻米麦麥母毋毌"},D=()=>{const a=[];for(const[h,c]of Object.entries(ne))Array.from(c).forEach(_=>{a.push({radical:_,key:h,due:new Date().getTime(),interval:1,repetition:0,efactor:2.5})});return be(a)};let f=v(J.MinPriorityQueue.fromArray(D(),a=>a.due)),d=v(void 0),L=0,w=v(!1);const x=()=>{f.value.isEmpty()||(d.value=f.value.dequeue(),L=performance.now())},ae=()=>{if(!d.value)return;let a;if(w.value)w.value=!1,a=0;else{const _=performance.now()-L;_<600?a=5:_<1e3?a=4:a=3}const h=Ve(d.value,a),c={...d.value,...h,due:d.value.due+h.interval*1e3*60*60*24};f.value.enqueue(c),localStorage.setItem("super-memo-data",JSON.stringify(f.value.toArray())),x()},oe=()=>{f.value.clear(),D().forEach(a=>f.value.enqueue(a)),x()},ue=()=>{d.value&&x()},he=a=>{var h;d&&(((h=d.value)==null?void 0:h.key)===a.toLowerCase()?ae():w.value=!0)},M=Q(()=>f.value.size()),O=Q(()=>f.value.toArray().filter(a=>a.repetition>0).length),B=Q(()=>f.value.toArray().filter(a=>a.repetition>1).length),le=v(null),$=v(!1);return ve(()=>{var h;const a=localStorage.getItem("super-memo-data");a&&(f.value=J.MinPriorityQueue.fromArray(JSON.parse(a),c=>c.due)),x(),(h=le.value)==null||h.focus()}),(a,h)=>(N(),we(n(t),{theme:n(se)},{default:u(()=>[o(n(s),{vertical:"",size:"large"},{default:u(()=>[y("div",Fe,[o(n(e),{onClick:oe},{default:u(()=>[p("重新开始")]),_:1}),o(n(e),{onClick:ue},{default:u(()=>[p("丢弃卡片")]),_:1}),o(n(e),{onClick:h[0]||(h[0]=c=>$.value=!0)},{default:u(()=>[p("使用说明")]),_:1})]),o(n(k),{show:$.value,"onUpdate:show":h[1]||(h[1]=c=>$.value=c)},{default:u(()=>[o(n(l),null,{default:u(()=>[o(n(te),null,{default:u(()=>[p("使用说明")]),_:1}),o(n(b),null,{default:u(()=>[p(" 程序集成了著名的 "),o(n(ie),{target:"_blank",href:"https://supermemo.guru/wiki/SuperMemo"},{default:u(()=>[p("SuperMemo")]),_:1}),p(" 记忆算法，能够有效的帮助用户快速且牢固的记忆声笔飞系的部首所在按键。 ")]),_:1}),o(n(b),null,{default:u(()=>[p(" 在（重新）开始训练时程序会将部首和对应的按键制作成一张张的卡牌，顺序是随机的。卡牌的正面是部首，背面是你需要输入的对应按键。在卡牌显示后，你要以最快的速度按下键盘上相应的按键。 ")]),_:1}),o(n(re),null,{default:u(()=>[o(n(C),null,{default:u(()=>[p(" 如果按键正确，则会自动显示下一张卡牌，且程序会根据你的响应时间来为你的记忆评级。程序会根据这个评级来安排该卡牌下次出现的时间，以便巩固你的记忆。 ")]),_:1}),o(n(C),null,{default:u(()=>[p("如果按键不正确，程序会提示你正确的按键是什么。")]),_:1})]),_:1}),o(n(b),null,{default:u(()=>[p(" 程序在运行时自动将当前进度记录到浏览器的本地存储当中，再次打开时会从本地存储中加载进度。 "),Ge]),_:1})]),_:1})]),_:1},8,["show"]),o(n(s),{vertical:"",align:"center"},{default:u(()=>[o(n(s),{align:"center"},{default:u(()=>[p(" 已学会"),o(n(r),{type:"line",percentage:O.value/M.value*100,style:{width:"160px"},"show-indicator":!1},null,8,["percentage"]),p(" "+H(`${O.value} / ${M.value}`),1)]),_:1}),o(n(s),{align:"center"},{default:u(()=>[p(" 已熟悉"),o(n(r),{type:"line",percentage:B.value/M.value*100,style:{width:"160px"},"show-indicator":!1},null,8,["percentage"]),p(" "+H(`${B.value} / ${M.value}`),1)]),_:1})]),_:1}),o(n(l),null,{header:u(()=>{var c,_;return[y("div",Ke,[y("span",null,H((c=n(d))==null?void 0:c.radical),1),n(w)?(N(),T("span",We," ["+H((_=n(d))==null?void 0:_.key)+"]",1)):xe("",!0)]),o(n(ee),{value:"",onInput:h[2]||(h[2]=pe=>he(pe)),placeholder:"请输入部首对应的按键",style:{"font-size":"16px"}})]}),footer:u(()=>[]),_:1})]),_:1})]),_:1},8,["theme"]))}}),Ye=y("h1",{id:"声笔条反",tabindex:"-1"},[p("声笔条反 "),y("a",{class:"header-anchor",href:"#声笔条反","aria-label":'Permalink to "声笔条反"'},"​")],-1),Ze=y("p",null,"利用科学方法高效记忆飞系方案中的部首。",-1),st=JSON.parse('{"title":"声笔条反","description":"","frontmatter":{"sidebar":false,"editLink":false,"lastUpdated":false},"headers":[],"relativePath":"sbtf/index.md","filePath":"sbtf/index.md"}'),et={name:"sbtf/index.md"},nt=Object.assign(et,{setup(i){return(e,t)=>(N(),T("div",null,[Ye,Ze,o(Xe)]))}});export{st as __pageData,nt as default};
